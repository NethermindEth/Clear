import Aesop

import Mathlib.Data.Rel
import Mathlib.Tactic.ApplyAt

instance instRelInter {α β} : Inter (Rel α β) where
  inter r s := λ a b ↦ r a b ∧ s a b

def Rel.inter {α β} (r : α → β → Prop) (s : α → β → Prop) : α → β → Prop :=
  λ a b ↦ r a b ∧ s a b

instance instFunInter {α β : Type} : Inter (α → β → Prop) where
  inter r s := λ a b ↦ r a b ∧ s a b

declare_aesop_rule_sets [Clear.aesop_ok, Clear.aesop_spec, Clear.aesop_varstore]

set_option hygiene false in
open Lean Elab Tactic in
/--
`aesop_spec` encapsulates general patterns pertaining to reasoning about verification conditions
generated by the `vc`.
* `aesop_spec` is equivalent to `aesop (rule_sets [Clear.aesop_spec])` (+nf).
-/
elab "aesop_spec" : tactic => do
  evalTactic <| ← `(tactic|
    aesop (rule_sets := [Clear.aesop_spec]) (config := { warnOnNonterminal := false })
  )

set_option hygiene false in
open Lean Elab Tactic in
/--
`aesop_ok` addresses problems pertaining to preservation of Ok states.
* `aesop_ok` is equivalent to `aesop (rule_sets [Clear.aesop_ok])` (+nf).
-/
elab "aesop_ok" : tactic => do
  evalTactic <| ← `(tactic|
    aesop (rule_sets := [Clear.aesop_ok]) (config := { warnOnNonterminal := false })
  )

set_option hygiene false in
open Lean Elab Tactic in
/--
`aesop_varstore` addresses problems pertaining to preservation of Ok states.
* `aesop_varstore` is equivalent to `aesop (rule_sets [Clear.aesop_varstore])` (+nf).
-/
elab "aesop_varstore" : tactic => do
  evalTactic <| ← `(tactic|
    aesop (rule_sets := [Clear.aesop_varstore]) (config := { warnOnNonterminal := false })
  )

set_option hygiene false in
open Lean Elab Tactic in
elab "clr_varstore" : tactic => do
  evalTactic <| ← `(tactic| (
    repeat (
      first | rw [State.lookup_insert (by assumption)] at * |
              rw [State.lookup_insert' (by aesop_spec)] at * |
              rw [State.lookup_insert_of_ne (by decide)] at *
    )
  )
  )
